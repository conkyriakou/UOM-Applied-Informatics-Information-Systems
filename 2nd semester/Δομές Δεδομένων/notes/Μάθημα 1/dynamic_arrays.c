/* 
	ΕΡ: Τι θα γινόταν αν εγώ ήθελα να προσθέσω στοιχείο στον πίνακα;
	ΑΠ: Το στοιχείο θα μπει στο τέλος του πίνακα.
	
	ΠΡΟΣΟΧΗ: Υπάρχουν δύο είδη δεσμεύσεων πίνακα!
		1ο είδος: ΣΤΑΤΙΚΗ ΔΕΣΜΕΥΣΗ
										int A[10];
										
			Είναι το πιο σύνηθες, προϋποθέτει ότι γνωρίζουμε είτε το ακριβές πλήθος των στοιχείων
			του πίνακα, είτε ότι το πλήθος των στοιχείων του πίνακα έχει ένα άνω όριο.
			Για παράδειγμα, στην παραπάνω εντολή, είτε το πλήθος θα είναι 10 ακέραιοι, είτε
			από 0 έως 10 το πολύ. 
			
			Αν ορίσεις ότι ο πίνακας έχει 10 στοιχεία, δεν μπορείς με άλλες εντολές να αλλάξεις το
			μέγεθός του. Αν δηλαδή θες να έχεις 11 στοιχεία στον πίνακα, απλά δεν μπορείς να τα έχεις.	
			
		2ο είδος: ΔΥΝΑΜΙΚΗ ΔΕΣΜΕΥΣΗ
									int *A = (int *) malloc (sizeof(int) * 10);
			
			ΕΡ: Τι είναι η malloc()?
			ΑΠ: Είναι μία συνάρτηση που λαμβάνει μία παράμετρο και επιστρέφει πίσω μία διεύθυνση.
				ΠΑΡΑΜΕΤΡΟΣ: Πλήθος των bytes που θέλουμε να δεσμεύσουμε στη μνήμη.
				ΔΙΕΥΘΥΝΣΗ: Η διεύθυνση του πρώτου byte από αυτά που δέσμευσε η malloc.
				
				malloc(1000) -> Θέλω να δεσμεύσω 1000 bytes (250 ακέραιοι, 1000 χαρακτήρες)
								H malloc πάει στη μνήμη, δεσμεύει 1000 συνέχομενα bytes, έστω
								από τη θέση 20000 μέχρι τη θέση 20999, και επιστρέφει πίσω την
								τιμή 20000, η οποία αντιστοιχεί στη θέση του πρώτου byte που 
								δεσμεύτηκε.
			
			ΕΡ: Τι είναι το sizeof()?
			ΑΠ: Ο τελεστής sizeof() μας επιστρέφει πίσω το πόσο χώρο πιάνει στη μνήμη μία μεταβλητή (a, i, nick),
				ή ένας τύπος μεταβλητής (char, int, float, double).
						sizeof(char) 	-> 	1
						sizeof(int)		->	4
						sizeof(float)	->	4
						sizeof(double)	->	8	
			
			ΕΡ: Τι σημαίνει εν τέλει το malloc (sizeof(int) * 10)?
			ΑΠ:	
				Ας ξεκινήσουμε από το sizeof(int) * 10. Αυτό υπολογίζει το χώρο που πιάνουν 10 ακέραιοι στη μνήμη.
			ουσιαστικά είναι σαν να λέω int Α[10]. 
				’ρα ζητάω από τη malloc να δεσμεύσει στη μνήμη χώρο ίσο με 4*10 == 40 bytes.
				Η malloc θα μου επιστρέψει πίσω τη διεύθυνση του 1ου byte που δέσμευσε.
			
			ΕΡ: Γιατί ενώ εγώ θέλω πίνακα, δηλώνω τον Α ως int *A ?
			ΑΠ:	Όλοι οι πίνακες στη C, είναι δείκτες, οι οποίοι δείχνουν στη διεύθυνση του πρώτου στοιχείου του πίνακα.
			Έστω ο πίνακας Α:
			
				Διεύθυνση στη μνήμη			  20	24	  28    32   36
											----------------------------
				Τιμή						| 4  |  5  |  9  | 14  | 2 |			
											----------------------------
				Στοιχείο					 Α[0]  Α[1]  Α[2]  Α[3] Α[4]
			
	
				Ερώτηση Κατανόησης:
					Τι τιμή θα έχει το Α στο πάνω παράδειγμα?
					printf("%d", A);		
				Απάντηση:
					20	

			ΕΡ: Γιατί δουλεύει τόσο καλά το να πω int *A σε συνδυασμό με τη malloc? 
				Τι κοινό παρατηρούμε στο πως λειτουργούν;
			ΑΠ: Ο pointer θέλει τη διεύθυνση του πρώτου στοιχείου και η malloc επιστρέφει τη διεύθυνση του 1ου byte, 
				η οποία είναι και η αρχική διεύθυνση του 1ου στοιχείου.
				
			
			ΕΡ: Οι διευθύνσεις μπορούν να είναι διεύθυνση προς ακέραιο (int *), διεύθυνση προς float (float *),
			διεύθυνση προς double (double *), διεύθυνση προς χαρακτήρα (char *). Επίσης η malloc σαν συνάρτηση
			πρέπει να έχει έναν τύπο επιστροφής, δηλαδή τον τύπο των δεδομένων που επιστρέφει.
			Τι τύπο επιστροφής θα έχει όμως, αν εγώ τη μία φορά θέλω να την καλώ για να μου φτιάχνει έναν πίνακα
			από doubles και την άλλη φορά την καλώ για να μου φτιάχνει έναν πίνακα ακεραίων; 
			Δε θα έπρεπε την πρώτη φορά να είναι (double *) και τη δεύτερη (int *)?
			
			ΑΠ: Οι σχεδιαστές της γλώσσας C έκαναν τη malloc να επιστρέφει πίσω διεύθυνση τύπου (void *).
				Αν μπεις σε ένα εγχειρίδιο θα δεις ότι θα λέει 
											(void *) malloc(size_t size)
				
				Για να το φέρεις στα μέτρα σου μπορείς να κάνεις το λεγόμενο type casting. Το type casting αλλάζει τον 
				τύπο μίας τιμής.
				
					(τελικός τύπος) τιμή
					
				Για συναρτήσεις λοιπόν:
					(int) f(3)
					
				Για τη malloc μπορούμε να πούμε:
					
						int *A = (int *) malloc(sizeof(int) * 10)
					
				Memory ALLOCation	<-> Δέσμευση μνήμης
							
							---- ΤΕΛΟΣ ΕΞΗΓΗΣΗΣ MALLOC ----
		
		ΕΡ: Καλά όλα αυτά, αλλά πως θα αλλάξω το μέγεθος του πίνακα Α, για να το κάνω πχ 11?
		ΑΠ: Μπορώ να χρησιμοποιήσω τη συνάρτηση (void *) realloc(void *ptr, size_t size)
		
			Συγκεκριμένα, η realloc παίρνει 2 παραμέτρους και επιστρέφει πίσω μία διεύθυνση: 
				1η παράμετρος: Τη διεύθυνση του pointer ο οποίος δείχνει στα δεδομένα που θέλουμε να τους 
					αλλάξουμε το μέγεθος (εδώ είναι ο πίνακας-δείκτης Α)
				2η παράμετρος: Το νέο μέγεθος
				Διεύθυνση: Η θέση του 1ου byte στη μνήμη που δέσμευσε τώρα.
			
			REALLOCate	<- Επαναδέσμευσε
			
			Εν τέλει σε κώδικα θα έγραφα
			
			Α = (int *) realloc(A, sizeof(int) * 11);
			
		ΕΡ: Πότε γράφω realloc()?
		ΑΠ: Πρώτα θα γράψει malloc() μία φορά ώστε να δεσμευτεί κάτι, και στη συνέχεια θα γράψεις realloc().
			Δε γίνεται να χρησιμοποιήσεις μόνο realloc().
			malloc γράφεις μία φορά στην αρχή. realloc όλες τις επόμενες που θέλεις να αλλάξεις το μέγεθος.	
		
							---- ΤΕΛΟΣ ΕΞΗΓΗΣΗΣ MALLOC ----

		ΕΡ: Υπάρχει και αποδέσμευση μνήμης? Αν ναι, γιατί;
		ΑΠ: Προφανώς και υπάρχει. Ο λόγος είναι ότι παλιά δεν είχαν αρκετό χώρο στους υπολογιστές, επόμενως έπρεπε
		κάθε byte να το λαμβάνουν υπόψιν. ’ρα μπορεί να ξεκινούσες και οι θέσεις 20 έως 39 να ήταν ένας πίνακας 
		ακεραίων στην αρχή, μετά να ήταν ένας πίνακας 20 χαρακτήρων που έβαζες το όνομά σου, μετά να ήταν 2 μεταβλητές 
		double... ’ρα άμα ο πίνακας των ακεραίων δεν είχε λόγο να υπάρχει μετά από λίγο (γιατί ό,τι εντολή έπρεπε να 
		εκτελέσεις με βάση τα δεδομένα του πίνακα την είχες εκτελέσει), τότε θα τον αποδέσμευες σε περίπτωση που ήθελες 
		να βάλεις κάτι άλλο.
		
		Σκέψου το σαν έναν πίνακα στο σχολείο. Κάθε φορά που γέμιζε και δεν είχες κάτι καινούριο να πεις με βάση αυτά 
		που υπήρχαν τον πίνακα (δηλαδή δεν ήταν χρήσιμα πλέον) μπορούσες απλά να σβήσεις τον πίνακα και να αρχίσεις
		να γράφεις νέα πράγματα που θα χρησίμευσαν στη συνέχεια στο μάθημα.
		
		ΕΡ: Πώς γίνεται η αποδέσμευση;
		ΑΠ: Με τη συνάρτηση void free(void *ptr)
			Η παράμετρος που λαμβάνει είναι η διεύθυνση του πρώτου byte της μνήμης που θες να αποδεσμεύσεις.
			
			free((void *) A);
			
			free(A);
		
*/

#include <stdio.h>
#include <stdbool.h>

void print_array(int *A, int size)
{
	printf("Printing the array...\n");
	int i;
	for (i=0; i<size; i++)
		printf("%d ", A[i]);
	printf("\n\n");		
}


// H insert_element το βάζει κατευθείαν στο τέλος.
// ’ρα μπορούμε να πούμε ότι έχουμε ένα σταθερό πλήθος πράξεων, ανεξάρτητο των 
// παραμέτρων, άρα μιλάμε για σταθερή χρονική πολυπλοκότητα Ο(1).
void insert_element(int *A, int *size, int elem)
{
	printf("INSERT(%d)\n", elem);
	printf("\tIncrementing the number of elements to %d...", *size+1);
	*size = *size + 1;
	printf("(OK)\n");
	printf("\tIncreasing size of array in the memory... ");
	A = (int *) realloc (A, sizeof(int) * (*size));
	printf("(OK)\n");
	printf("\tPlacing element %d at position %d...", elem, *size-1);
	A[*size-1] = elem;
	printf("(OK)\n");
	printf("SUCCESS\n\n");
}

// Η delete_element χρειάζεται στη χειρότερη περίπτωση Ν-1 μεταφορές στοιχείων, 
// δηλαδή έχει χρονική πολυπλοκότητα Ο(Ν)
void delete_element(int *A, int *size, int index)
{
	printf("DELETE(%d)\n", index);
	if (index<0||index>=*size)
	{
		printf("Index is out of bounds.\n");
		printf("FAILURE\n\n");
	}
	else
	{
		printf("\tMoving elements from position %d to %d one place left...", index+1, *size-1);
		int i;
		for (i=index+1; i<*size; i++)
		{
			A[i-1] = A[i];
		}	
		printf("(OK)\n");
		printf("\tDecrementing the number of elements to %d...", *size-1);
		*size = *size - 1;
		printf("(OK)\n");
		printf("\tDecreasing size of array in the memory... ");
		A = (int *) realloc(A, sizeof(int) * (*size));
		printf("(OK)\n");
		printf("SUCCESS\n\n");		
	}
}

// 	Το πλήθος των ελέγχων για πλήθος Ν στοιχείων θα είναι στη γενική περίπτωση Ν.
//	Αυτό μπορούμε να πούμε ότι έχει χρονική πολυπλοκότητα Ο(Ν).
void search_element(int *A, int size, int elem)
{
	int i;
	bool found = false;
	for (i=0; i<size; i++)
	{
		if (A[i] == elem)
		{
			printf("Element %d found at position %d.\n", elem, i);
			found = true;
		}
	}	
	
	if (found == false)
	{
		printf("Element %d does not exist in the array.\n", elem);
	}
}

int menu()
{
	int choice;
	printf("--- ARRAYS ---\n");
	printf("1. Print array\n");
	printf("2. Insert element\n");
	printf("3. Delete element\n");
	printf("4. Search element\n");
	printf("Choice: ");
	scanf("%d", &choice);
	return choice;
}

int main(void)
{
	int *A = (int *) malloc(sizeof(int));
	int size = 0;
	int choice;
	do {
		choice = menu();
		if (choice == 1)
			print_array(A, size);
		else if (choice == 2)
		{
			int elem;
			printf("Give element: ");
			scanf("%d", &elem);
			insert_element(A, &size, elem);
		}
		else if (choice == 3)
		{
			int index;
			printf("Give index: ");
			scanf("%d", &index);
			delete_element(A, &size, index);
		}
		else if (choice == 4)
		{
			int elem;
			printf("Give element: ");
			scanf("%d", &elem);
			search_element(A, size, elem);
		}
	} while (choice>=1 && choice <=4);
	
	free((void *) A);
	
	return 0;
}
